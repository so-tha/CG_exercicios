<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Terra</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script>
      var scene = new THREE.Scene();
      //A câmera perspectiva simula a forma como os objetos aparecem em um ambiente tridimensional.
      var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      //converte a cena e a câmera em imagens para serem exibidas no navegador.
      var renderer = new THREE.WebGLRenderer();
      //faz com que o tamanho da imagem final fique do mesmo tamanho da janela do navegador.
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);//anexo da cena no html

      // Criando a Geometria da Esfera ( nesse caso essa é a da Terra e do Sol)
      var geometry_sphere = new THREE.SphereGeometry();
    

      const loader = new THREE.TextureLoader();
      const texture1 = loader.load( '/CompGrafica/terra2.jpg' );
      texture1.colorSpace = THREE.SRGBColorSpace;//garante que as cores sejam exibidas corretamente
      
      const material_sphere1 = new THREE.MeshBasicMaterial({
        map: texture1, //Cria um material básico (MeshBasicMaterial) para aplicar na esfera
      });

      //Textura do sol
      const texture2 = loader.load( '/CompGrafica/sun.jpeg' );
      texture2.colorSpace = THREE.SRGBColorSpace;
      
      const material_sphere2 = new THREE.MeshBasicMaterial({
        map: texture2,
      });

      var sphere1 = new THREE.Mesh(geometry_sphere, material_sphere1);
      var sphere2 = new THREE.Mesh(geometry_sphere, material_sphere2);

      // Definindo tamanhos diferentes usando escala
      //A escala é um vetor que define a ampliação ou redução do objeto em cada dimensão (x, y, z).

      sphere1.scale.set(1, 1, 1); // Tamanho original
      sphere2.scale.set(2, 2, 2); 

      scene.add(sphere1);
      scene.add(sphere2);

      //posicionando os eixos da camera

      camera.position.z = 8;
      camera.position.y= 2;
      camera.position.x = 2;

      function animate() {
        
        requestAnimationFrame(animate);

        //rotacionando em torno do eixo y, para imitar o movimento de fato da terra
        sphere1.rotation.y += 0.001;
        sphere2.rotation.y += 0.001;
        //sphere1.rotation.z += 0.0002; //tentativa de inclinação igual a terra de fato faz

        // Movendo o cubo em uma órbita circular
        const radius = 4; // Raio da órbita
        const speed = 0.001; // Velocidade menor da orbita para simular com mais realismo

        sphere1.position.x = Math.cos(speed * Date.now()) * radius;
        //Math.cos ta calculando o valor do cosseno que aumenta com o tempo(Date.now) com a velocidade mais o fator de reajuste(sem ele a esfera gira muito mais rapido)
        //Da como resultado um valor que fica entre -1 e 1, representando a posição horizontal da esfera.
        sphere1.position.z = Math.sin(speed * Date.now()) * radius;
        //aqui a mesma coisa esta sendo feita só que na vertical
        //radius multiplica o resultado pelo raio da órbita, oq dimensiona a posição da esfera

        // Atualizando a câmera para olhar para o centro da órbita
        camera.lookAt(scene.position);

        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>

